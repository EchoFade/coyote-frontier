using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Content.Shared._Coyote.RolePlayIncentiveShared;
using Content.Shared.Alert;
using Content.Shared.Bed.Sleep;
using Content.Shared.Examine;
using Content.Shared.Humanoid;
using Content.Shared.IdentityManagement;
using Content.Shared.Mind.Components;
using Content.Shared.Mobs.Systems;
using Content.Shared.Movement.Systems;
using Content.Shared.Overlays;
using Content.Shared.Popups;
using Content.Shared.Rejuvenate;
using Content.Shared.SSDIndicator;
using Content.Shared.StatusIcon;
using Content.Shared.Verbs;
using Robust.Shared.Enums;
using Robust.Shared.Player;
using Robust.Shared.Prototypes;
using Robust.Shared.Random;
using Robust.Shared.Timing;
using Robust.Shared.Utility;

namespace Content.Shared._Coyote.Needs;

/// <summary>
/// This handles your needs.
/// </summary>
public abstract class SharedNeedsSystem : EntitySystem
{
    [Dependency] private readonly ISharedPlayerManager _players = default!;
    [Dependency] private readonly MovementSpeedModifierSystem _movement = default!;
    [Dependency] private readonly IGameTiming _timing = default!;
    [Dependency] private readonly AlertsSystem _alerts = default!;
    [Dependency] private readonly IPrototypeManager _prototype = default!;
    [Dependency] private readonly IEntityManager _entMan = default!;
    [Dependency] private readonly IRobustRandom _random = default!;
    [Dependency] private readonly SharedHumanoidAppearanceSystem _humanoid = default!;
    [Dependency] private readonly ExamineSystemShared _examineSystem = default!;
    [Dependency] private readonly SharedPopupSystem _popupSystem = null!;
    [Dependency] private readonly MobStateSystem _mobState = default!;

    private int _decayIterations = 1;
    private TimeSpan _nextDecIterRoll = TimeSpan.Zero;

    /// <inheritdoc/>
    public override void Initialize()
    {
        base.Initialize();
        SubscribeLocalEvent<NeedsComponent, ComponentInit>(OnInit);
        SubscribeLocalEvent<NeedsComponent, ComponentShutdown>(OnShutdown);
        SubscribeLocalEvent<NeedsComponent, RefreshMovementSpeedModifiersEvent>(OnRefreshMovespeed);
        SubscribeLocalEvent<NeedsComponent, RejuvenateEvent>(OnRejuvenate);
        SubscribeLocalEvent<NeedsComponent, GetRpiModifier>(OnGetRoleplayIncentive);
        SubscribeLocalEvent<NeedsComponent, GetVerbsEvent<ExamineVerb>>(OnGetExamineVerbs);
    }

    #region Event Handlers
    private void OnInit(EntityUid uid, NeedsComponent component, ComponentInit args)
    {
        LoadNeeds(uid, component);
    }

    private void OnShutdown(EntityUid uid, NeedsComponent component, ComponentShutdown args)
    {
        foreach (var need in component.Needs.Values)
        {
            _alerts.ClearAlertCategory(uid, need.AlertCategory);
        }
    }

    private void OnRefreshMovespeed(EntityUid uid,
        NeedsComponent component,
        ref RefreshMovementSpeedModifiersEvent args)
    {
        foreach (var need in component.Needs.Values)
        {
            need.ApplyMovementSpeedModifier(ref args);
        }
    }

    private void OnRejuvenate(EntityUid uid, NeedsComponent component, ref RejuvenateEvent args)
    {
        component.Needs.Clear();
        LoadNeeds(uid, component);
        InitializeNextUpdate(uid, component);
        UpdateMovespeed(uid, component);
        UpdateAlerts(uid, component, true);
    }

    private void OnGetRoleplayIncentive(EntityUid uid, NeedsComponent component, ref GetRpiModifier args)
    {
        foreach (var need in component.Needs.Values)
        {
            need.ModifyRpiEvent(ref args);
        }
    }
    private void OnGetExamineVerbs(EntityUid uid, NeedsComponent needy, GetVerbsEvent<ExamineVerb> args)
    {
        var detailsRange = _examineSystem.IsInDetailsRange(args.User, uid);

        var verb = new ExamineVerb()
        {
            Act = () =>
            {
                var markup = GetNeedsExamineText(uid, needy, args);
                _examineSystem.SendExamineTooltip(
                    args.User,
                    uid,
                    markup,
                    false,
                    false);
            },
            Text = Loc.GetString("examinable-need-verb-text"),
            Category = VerbCategory.Examine,
            Disabled = !detailsRange,
            Message = detailsRange ? null : Loc.GetString("examinable-need-verb-disabled"),
            Icon = new SpriteSpecifier.Texture(new("/Textures/Interface/NavMap/beveled_triangle.png"))
        };

        args.Verbs.Add(verb);
    }
    #endregion

    #region Examine stuff
    /// <summary>
    /// Gets the examine text for all needs on an entity.
    /// The REAL examine text is generated by Server, cus the client is purple and doesnt know anything!
    /// </summary>
    protected virtual FormattedMessage GetNeedsExamineText(
        EntityUid examinee,
        NeedsComponent component,
        GetVerbsEvent<ExamineVerb> args)
    {
        var returnMessage = new FormattedMessage();
        returnMessage.AddMarkupPermissive("[color=yellow]Loading...[/color]");
        return returnMessage;
    }

    #endregion
    #region Helpers
    public void LoadNeeds(EntityUid uid, NeedsComponent component)
    {
        component.Ready = false;
        component.Needs.Clear();
        foreach (var need in component.NeedPrototypes)
        {
            _prototype.TryIndex(need, out var proto);
            if (proto == null)
                continue;
            var protoKind = Enum.Parse<NeedType>(proto.NeedKind);
            var datum = new NeedDatum(proto);
            component.Needs[protoKind] = datum;
        }
        InitializeNextUpdate(uid, component);
        _movement.RefreshMovementSpeedModifiers(uid);
        component.Ready = true;
    }

    private void InitializeNextUpdate(EntityUid uid, NeedsComponent component)
    {
        var curTime = _timing.CurTime;
        var shortestDelay = TimeSpan.MaxValue;
        foreach (var need in component.Needs.Values)
        {
            if (need.UpdateRateSeconds < shortestDelay)
            {
                shortestDelay = need.UpdateRateSeconds;
            }
            need.NextUpdateTime = curTime + need.UpdateRateSeconds;
        }
        component.MinUpdateTime = shortestDelay;
        component.NextUpdateTime = curTime + component.MinUpdateTime;
    }

    private bool IsAsleeping(EntityUid uid)
    {
        // if the mob never had a mind, just count them as asleeping
        if (TryComp<MindContainerComponent>(uid, out var mindComp))
        {
            if (!mindComp.HasHadMind)
                return true;
            if (mindComp.IsInCryosleep)
                return true;
        }
        if (HasComp<SleepingComponent>(uid))
            return true;
        if (TryComp<SSDIndicatorComponent>(uid, out var ssd)
           && ssd.IsSSD)
            return true;

        if (!_players.TryGetSessionByEntity(uid, out var sesh))
            return true;
        return false;
    }

    #endregion

    #region Generic Need Helpers
    public bool TryGetStatusIconPrototype(
        EntityUid uid,
        NeedType kind,
        NeedsComponent component,
        [NotNullWhen(true)] out SatiationIconPrototype? prototype)
    {
        if (!HasComp<NeedsComponent>(uid))
        {
            prototype = null;
            return false;
        }
        var need = component.Needs.GetValueOrDefault(kind);
        if (need == null)
        {
            prototype = null;
            return false;
        }
        if (need.GetCurrentStatusIcon(out var iconId)
            && !string.IsNullOrEmpty(iconId))
        {
            return IoCManager.Resolve<IPrototypeManager>()
                .TryIndex(
                    iconId,
                    out prototype);
        }

        prototype = null;
        return false;
    }
    /// <summary>
    /// Gets the current level of a specific need for an entity.
    /// </summary>
    public float? TryGetNeedLevel(
        EntityUid uid,
        NeedType needType,
        NeedsComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return null;

        if (component.Needs.TryGetValue(needType, out var need))
        {
            return need.CurrentValue;
        }
        return null;
    }

    /// <summary>
    /// Gets the current threshold of a specific need for an entity.
    /// </summary>
    public NeedThreshold? TryGetNeedThreshold(
        EntityUid uid,
        NeedType needType,
        NeedsComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return null;

        if (component.Needs.TryGetValue(needType, out var need))
        {
            return need.GetCurrentThreshold();
        }
        return null;
    }

    /// <summary>
    /// Gets the minimum threshold of a specific threshold of a need for an entity.
    /// </summary>
    public float? TryGetNeedMinThreshold(
        EntityUid uid,
        NeedType needType,
        NeedThreshold threshold,
        NeedsComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return null;
        if (component.Needs.TryGetValue(needType, out var need))
        {
            return need.GetValueForThreshold(threshold);
        }
        return null;
    }

    /// <summary>
    /// Modifies the current level of a specific need for an entity.
    /// </summary>
    public bool TryModifyNeedLevel(
        EntityUid uid,
        NeedType needType,
        float amount,
        NeedsComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return false;
        if (component.Needs.TryGetValue(needType, out var need))
        {
            need.ModifyCurrentValue(amount);
            UpdateEverything(uid, component);
            return true;
        }
        return false;
    }

    /// <summary>
    /// Tries to set the current level of a specific need for an entity.
    /// </summary>
    public bool TrySetNeedLevel(
        EntityUid uid,
        NeedType needType,
        float amount,
        NeedsComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return false;
        if (component.Needs.TryGetValue(needType, out var need))
        {
            need.SetCurrentValue(amount);
            UpdateEverything(uid, component);
            return true;
        }
        return false;
    }

    /// <summary>
    /// Sets the current level of a specific need to the minimum value of a specific threshold for an entity.
    /// </summary>
    public bool SetNeedToThreshold(
        EntityUid uid,
        NeedType needType,
        NeedThreshold threshold,
        NeedsComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return false;
        if (component.Needs.TryGetValue(needType, out var need))
        {
            var minValue = need.GetValueForThreshold(threshold);
            need.SetCurrentValue(minValue);
            UpdateEverything(uid, component);
            return true;
        }
        return false;
    }

    /// <summary>
    /// Checks if the entity's specific need is below a certain threshold.
    /// </summary>
    public bool IsBelowThreshold(
        EntityUid uid,
        NeedType needType,
        NeedThreshold threshold,
        NeedsComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return false;
        if (component.Needs.TryGetValue(needType, out var need))
        {
            return need.IsBelowThreshold(threshold);
        }
        return false;
    }

    /// <summary>
    /// Does the entity have a specific need?
    /// </summary>
    public bool HasNeed(
        EntityUid uid,
        NeedType needType,
        NeedsComponent? component = null)
    {
        if (!Resolve(uid, ref component))
            return false;
        return component.Needs.ContainsKey(needType);
    }

    /// <summary>
    /// Compares two thresholds and returns the more severe one.
    /// </summary>
    public NeedThreshold? CompareThresholds(NeedThreshold? a, NeedThreshold? b)
    {
        if (a == null && b == null)
            return null;
        if (a == null)
            return b;
        if (b == null)
            return a;
        return (NeedThreshold)Math.Max((int)a, (int)b);
    }

    #endregion

    #region Hunger Helpers
    /// <summary>
    /// Gets the Hunger level of an entity.
    /// </summary>
    public float? GetHunger(
        EntityUid uid,
        NeedsComponent? component = null)
    {
        return TryGetNeedLevel(
            uid,
            NeedType.Hunger,
            component);
    }

    /// <summary>
    /// Does the entity use Hunger as a need?
    /// </summary>
    public bool UsesHunger(EntityUid uid, NeedsComponent? component = null)
    {
        return HasNeed(
            uid,
            NeedType.Hunger,
            component);
    }

    /// <summary>
    /// Modifies the Hunger level of an entity.
    /// </summary>
    public bool ModifyHunger(EntityUid uid, float amount, NeedsComponent? component = null)
    {
        return TryModifyNeedLevel(
            uid,
            NeedType.Hunger,
            amount,
            component);
    }

    /// <summary>
    /// Sets the Hunger level of an entity.
    /// </summary>
    public bool SetHunger(EntityUid uid, float amount, NeedsComponent? component = null)
    {
        return TrySetNeedLevel(
            uid,
            NeedType.Hunger,
            amount,
            component);
    }

    public bool TryGetHungerStatusIconPrototype(EntityUid uid,
        [NotNullWhen(true)] out SatiationIconPrototype? prototype,
        NeedsComponent? component = null)
    {
        if (!Resolve(uid, ref component))
        {
            prototype = null;
            return false;
        }

        return TryGetStatusIconPrototype(
            uid,
            NeedType.Hunger,
            component,
            out prototype);
    }

    /// <summary>
    /// Hunger is below this threshold
    /// </summary>
    public bool HungerIsBelowThreshold(EntityUid uid, NeedThreshold threshold, NeedsComponent? component = null)
    {
        return IsBelowThreshold(
            uid,
            NeedType.Hunger,
            threshold,
            component);
    }

    /// <summary>
    /// Gets the current threshold of Hunger for an entity.
    /// </summary>
    public NeedThreshold? GetHungerThreshold(EntityUid uid, NeedsComponent? component = null)
    {
        return TryGetNeedThreshold(
            uid,
            NeedType.Hunger,
            component);
    }

    /// <summary>
    /// Gets the minimum threshold of a specific threshold of Hunger for an entity.
    /// </summary>
    public float? GetHungerMinThreshold(EntityUid uid, NeedThreshold threshold, NeedsComponent? component = null)
    {
        return TryGetNeedMinThreshold(
            uid,
            NeedType.Hunger,
            threshold,
            component);
    }

    /// <summary>
    /// Sets the current level of Hunger to the minimum value of a specific threshold for an entity.
    /// </summary>
    public bool SetHungerToThreshold(
        EntityUid uid,
        NeedThreshold threshold = NeedThreshold.Satisfied,
        NeedsComponent? component = null)
    {
        return SetNeedToThreshold(
            uid,
            NeedType.Hunger,
            threshold,
            component);
    }
    #endregion

    #region Thirst Helpers
    /// <summary>
    /// Gets the Thirst level of an entity.
    /// </summary>
    public float? GetThirst(EntityUid uid, NeedsComponent? component = null)
    {
        return TryGetNeedLevel(
            uid,
            NeedType.Thirst,
            component);
    }

    /// <summary>
    /// Modifies the Thirst level of an entity.
    /// </summary>
    public bool ModifyThirst(EntityUid uid, float amount, NeedsComponent? component = null)
    {
        return TryModifyNeedLevel(
            uid,
            NeedType.Thirst,
            amount,
            component);
    }

    /// <summary>
    /// Sets the Thirst level of an entity.
    /// </summary>
    public bool SetThirst(EntityUid uid, float amount, NeedsComponent? component = null)
    {
        return TrySetNeedLevel(
            uid,
            NeedType.Thirst,
            amount,
            component);
    }

    /// <summary>
    /// Does the entity use Thirst as a need?
    /// </summary>
    public bool UsesThirst(EntityUid uid, NeedsComponent? component = null)
    {
        return HasNeed(
            uid,
            NeedType.Thirst,
            component);
    }

    /// <summary>
    /// Thirst is below this threshold
    /// </summary>
    public bool ThirstIsBelowThreshold(EntityUid uid, NeedThreshold threshold, NeedsComponent? component = null)
    {
        return IsBelowThreshold(
            uid,
            NeedType.Thirst,
            threshold,
            component);
    }

    public bool TryGetThirstStatusIconPrototype(EntityUid uid,
        [NotNullWhen(true)] out SatiationIconPrototype? prototype,
        NeedsComponent? component = null)
    {
        if (!Resolve(uid, ref component))
        {
            prototype = null;
            return false;
        }

        return TryGetStatusIconPrototype(
            uid,
            NeedType.Thirst,
            component,
            out prototype);
    }

    /// <summary>
    /// Gets the current threshold of Thirst for an entity.
    /// </summary>
    public NeedThreshold? GetThirstThreshold(EntityUid uid, NeedsComponent? component = null)
    {
        return TryGetNeedThreshold(
            uid,
            NeedType.Thirst,
            component);
    }

    /// <summary>
    /// Sets the current level of Thirst to the minimum value of a specific threshold for an entity.
    /// </summary>
    public bool SetThirstToThreshold(
        EntityUid uid,
        NeedThreshold threshold = NeedThreshold.Satisfied,
        NeedsComponent? component = null)
    {
        return SetNeedToThreshold(
            uid,
            NeedType.Thirst,
            threshold,
            component);
    }

    /// <summary>
    /// Gets the minimum threshold of a specific threshold of Thirst for an entity.
    /// </summary>
    public float? GetThirstMinThreshold(EntityUid uid, NeedThreshold threshold, NeedsComponent? component = null)
    {
        return TryGetNeedMinThreshold(
            uid,
            NeedType.Thirst,
            threshold,
            component);
    }
    #endregion

    #region Updates
    public override void Update(float frameTime)
    {
        base.Update(frameTime);
        var curTime = _timing.CurTime;
        var query = EntityQueryEnumerator<NeedsComponent>();
        while (query.MoveNext(out var uid, out var component))
        {
            if (component.Needs.Count == 0)
                continue;
            if (!component.Ready)
                continue;
            if (component.NextUpdateTime > curTime)
                continue;

            var deltaSeconds = (float) (curTime - (component.NextUpdateTime - component.MinUpdateTime)).TotalSeconds;
            component.NextUpdateTime = curTime + component.MinUpdateTime;

            if (_mobState.IsDead(uid))
                continue;
            var sleeping = IsAsleeping(uid);

            foreach (var need in component.Needs.Values)
            {
                // for (var i = 0; i < _decayIterations; i++)
                // {
                //     need.Decay(deltaSeconds, sleeping);
                //     need.TickDebuffSlows(curTime);
                // }
                need.Decay(deltaSeconds, sleeping);
            }
            UpdateEverything(uid, component);
        }
        // RerollDecayIterations();
    }

    private void UpdateEverything(EntityUid uid, NeedsComponent component)
    {
        var updated = false;
        foreach (var need in component.Needs.Values)
        {
            if (need.UpdateCurrentThreshold().Changed)
                updated = true;
        }

        UpdateAlerts(
            uid,
            component,
            updated);
        UpdateMovespeed(
            uid,
            component);
    }

    private void UpdateMovespeed(EntityUid uid, NeedsComponent component)
    {
        var hasMoveUpdate = false;
        foreach (var need in component.Needs.Values)
        {
            if (need.HasQueuedMoveUpdate())
            {
                hasMoveUpdate = true;
            }
        }
        if (!hasMoveUpdate)
            return;
        List<string> reports = new();
        foreach (var need in component.Needs.Values)
        {
            var slowDebuffReport = need.GetDebuffSlowMessages();
            if (slowDebuffReport.Count > 0)
                reports.AddRange(slowDebuffReport);
        }
        if (reports.Count > 0)
        {
            var message = string.Join("\n", reports);
            _popupSystem.PopupEntity(
                message,
                uid,
                uid,
                PopupType.MediumCaution);
        }
        _movement.RefreshMovementSpeedModifiers(uid);
    }

    private void UpdateAlerts(EntityUid uid, NeedsComponent component, bool updated = false)
    {
        if (!updated)
            return;
        foreach (var need in component.Needs.Values)
        {
            var alertProto = need.GetCurrentAlert();
            if (!_alerts.TryGet(alertProto, out var _))
            {
                var alertCat = need.AlertCategory;
                _alerts.ClearAlertCategory(uid, alertCat);
                continue;
            }
            _alerts.ShowAlert(uid, alertProto);
        }
    }

    private void RerollDecayIterations()
    {
        var curTime = _timing.CurTime;
        if (curTime < _nextDecIterRoll)
            return;
        _nextDecIterRoll = curTime + TimeSpan.FromMinutes(5);
        _decayIterations = 1;
        var i = 0;
        const int maxIters = 10;
        while (_random.Prob(0.25f)
               && i < maxIters)
        {
            _decayIterations++;
            i++;
        }
        // produces this distribution:
        // 1: 75%
        // 2: 18.75%
        // 3: 4.6875%
        // 4: 1.171875%
        // 5: 0.29296875%
        // 6: 0.0732421875%
        // 7: 0.018310546875%
        // 8: 0.00457763671875%
        // 9: 0.0011444091796875%
        // 10: 0.000286102294921875%
        // rolled every 5 minutes, so over the course of a 7 day long round, you'd expect:
        // 7 days = 10080 minutes
        // 10080 / 5 = 2016 rolls
        // 1  - 1512 times
        // 2  - 378 times
        // 3  - 94 times
        // 4  - 23 times
        // 5  - 5 times
        // 6  - 1 times
        // 7  - 0 times
        // 8  - 0 times
        // 9  - 0 times
        // 10 - 0 times
    }
    #endregion

}
